"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[28595],{864938:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"data-structures/hashtable/kademlia","title":"Kademlia","description":"Kademlia is a distributed hash table for decentralized peer-to-peercomputer networks designed by Petar Maymounkov and David Mazi\xe8res in 2002. It specifies the structure of the network and the exchange of information through node) lookups. Kademlia nodes communicate among themselves using UDP. A virtual or overlay network is formed by the participant nodes. Each node is identified by a number or node ID. The node ID serves not only as identification, but the Kademlia algorithm uses the node ID to locate values (usually file hashes or keywords). In fact, the node ID provides a direct map to file hashes and that node stores information on where to obtain the file or resource.","source":"@site/docs/data-structures/hashtable/kademlia.md","sourceDirName":"data-structures/hashtable","slug":"/data-structures/hashtable/kademlia","permalink":"/data-structures/hashtable/kademlia","draft":false,"unlisted":false,"editUrl":"https://github.com/rajacsp/rajacsp.github.io/tree/master/docs/data-structures/hashtable/kademlia.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"HyperLogLog","permalink":"/data-structures/hashtable/hyperloglog"},"next":{"title":"List of Hash Functions","permalink":"/data-structures/hashtable/list-of-hash-functions"}}');var r=a(474848),n=a(28453);const s={},o="Kademlia",d={},h=[{value:"References",id:"references",level:2}];function l(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"kademlia",children:"Kademlia"})}),"\n",(0,r.jsxs)(t.p,{children:["Kademlia is a ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Distributed_hash_table",children:"distributed hash table"})," for decentralized ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Peer-to-peer",children:"peer-to-peer"}),(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Computer_network",children:"computer networks"})," designed by Petar Maymounkov and David Mazi\xe8res in 2002. It specifies the structure of the network and the exchange of information through ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Node_(networking)",children:"node"})," lookups. Kademlia nodes communicate among themselves using ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/User_Datagram_Protocol",children:"UDP"}),". A virtual or ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Overlay_network",children:"overlay network"})," is formed by the participant nodes. Each node is identified by a number or node ID. The node ID serves not only as identification, but the Kademlia algorithm uses the node ID to locate values (usually file ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Hash_function",children:"hashes"})," or keywords). In fact, the node ID provides a direct map to file hashes and that node stores information on where to obtain the file or resource."]}),"\n",(0,r.jsx)(t.p,{children:"When searching for some value, the algorithm needs to know the associated key and explores the network in several steps. Each step will find nodes that are closer to the key until the contacted node returns the value or no more closer nodes are found. This is very efficient: like many other DHTs, Kademlia contacts only O(log(n)) nodes during the search out of a total of n nodes in the system."}),"\n",(0,r.jsxs)(t.p,{children:["Further advantages are found particularly in the decentralized structure, which increases the resistance against a ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Denial-of-service_attack",children:"denial-of-service attack"}),'. Even if a whole set of nodes is flooded, this will have limited effect on network availability, since the network will recover itself by knitting the network around these "holes".']}),"\n",(0,r.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Kademlia",children:"https://en.wikipedia.org/wiki/Kademlia"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://github.com/bmuller/kademlia",children:"https://github.com/bmuller/kademlia"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=_kCHOpINA5g&ab_channel=AsliEngineeringbyArpitBhayani",children:"Kademlia - a Distributed Hash Table implementation to power the overlay network of BitTorrent - YouTube"})})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>o});var i=a(296540);const r={},n=i.createContext(r);function s(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);