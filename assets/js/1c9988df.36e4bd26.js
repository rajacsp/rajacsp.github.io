"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[86535],{312037:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"technologies/kafka/migration-mirroring-replication","title":"Migration / Mirroring / Replication","description":"Cross-Cluster Data Mirroring","source":"@site/docs/technologies/kafka/migration-mirroring-replication.md","sourceDirName":"technologies/kafka","slug":"/technologies/kafka/migration-mirroring-replication","permalink":"/technologies/kafka/migration-mirroring-replication","draft":false,"unlisted":false,"editUrl":"https://github.com/rajacsp/rajacsp.github.io/tree/master/docs/technologies/kafka/migration-mirroring-replication.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1760616071000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"kafkacat","permalink":"/technologies/kafka/kafkacat"},"next":{"title":"Monitoring","permalink":"/technologies/kafka/monitoring"}}');var i=t(474848),o=t(28453);const a={},s="Migration / Mirroring / Replication",c={},l=[{value:"Cross-Cluster Data Mirroring",id:"cross-cluster-data-mirroring",level:2},{value:"MirrorMaker 2.0",id:"mirrormaker-20",level:2},{value:"Architecture components",id:"architecture-components",level:3},{value:"Highlights of the Mirror Maker 2.0",id:"highlights-of-the-mirror-maker-20",level:3},{value:"MirrorMaker 2 Limitations",id:"mirrormaker-2-limitations",level:3},{value:"Offset Mapping",id:"offset-mapping",level:3},{value:"Offset Translation",id:"offset-translation",level:4},{value:"Links",id:"links",level:3},{value:"Confluent Replicator vs MirrorMaker 2.0",id:"confluent-replicator-vs-mirrormaker-20",level:2},{value:"Migration",id:"migration",level:2},{value:"Cluster Linking",id:"cluster-linking",level:2},{value:"Scaling",id:"scaling",level:2},{value:"Others",id:"others",level:2}];function h(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"migration--mirroring--replication",children:"Migration / Mirroring / Replication"})}),"\n",(0,i.jsx)(r.h2,{id:"cross-cluster-data-mirroring",children:"Cross-Cluster Data Mirroring"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Multicluster architecture","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Hub-and-Spokes architecture"}),"\n",(0,i.jsx)(r.li,{children:"Active-Active architecture"}),"\n",(0,i.jsx)(r.li,{children:"Active-standby architecture"}),"\n",(0,i.jsx)(r.li,{children:"Stretch clusters"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"MirrorMaker1 and MirrorMaker2"}),"\n",(0,i.jsxs)(r.li,{children:["Other cross-cluster mirroring solutions","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Uber uReplicator"}),"\n",(0,i.jsxs)(r.li,{children:["Confluent's Replicator - ",(0,i.jsx)(r.a,{href:"https://docs.confluent.io/platform/current/multi-dc-deployments/replicator/index.html",children:"Replicator Overview | Confluent Documentation"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"mirrormaker-20",children:"MirrorMaker 2.0"}),"\n",(0,i.jsx)(r.p,{children:"MirrorMaker, is simple a Kafka consumer and producer, linked together with a queue. Can aggregate messages from two local clusters into an aggregate cluster, and then copying that cluster to other datacenters."}),"\n",(0,i.jsx)(r.h3,{id:"architecture-components",children:"Architecture components"}),"\n",(0,i.jsx)(r.p,{children:"To successfully understand how MirrorMaker 2 works, one needs to keep in mind that MirrorMaker 2 is built on top of Kafka Connect. Kafka Connect is a framework within Apache Kafka that eases the integration of Kafka with other systems. Indeed, it allows developers to stream data to Kafka from various external sources and vice versa (i.e., from Kafka to external systems). Kafka Connect operates in a scalable and fault-tolerant manner using connector plugins. MirrorMaker 2 relies on three key Kafka Connectors to perform data and offset replications. These special connectors are as follows:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Source Connector"})," is responsible for replicating the data between Kafka clusters."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Checkpoint Connector"})," is responsible for consumer groups offsets translation."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Heartbeat Connector"})," enables the monitoring of the health of a MirrorMaker 2 instance."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://developers.redhat.com/articles/2023/11/13/demystifying-kafka-mirrormaker-2-use-cases-and-architecture#architecture_design_scenarios",children:"Demystifying Kafka MirrorMaker 2: Use cases and architecture | Red Hat Developer"})}),"\n",(0,i.jsx)(r.h3,{id:"highlights-of-the-mirror-maker-20",children:"Highlights of the Mirror Maker 2.0"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Leverages the Kafka Connect framework and ecosystem."}),"\n",(0,i.jsx)(r.li,{children:"Includes both source and sink connectors."}),"\n",(0,i.jsx)(r.li,{children:"Includes a high-level driver that manages connectors in a dedicated cluster."}),"\n",(0,i.jsx)(r.li,{children:"Detects new topics, partitions."}),"\n",(0,i.jsx)(r.li,{children:"Automatically syncs topic configuration between clusters."}),"\n",(0,i.jsx)(r.li,{children:"Manages downstream topic ACL."}),"\n",(0,i.jsx)(r.li,{children:'Supports "active/active" cluster pairs, as well as any number of active clusters.'}),"\n",(0,i.jsx)(r.li,{children:"Supports cross-datacenter replication, aggregation, and other complex topologies."}),"\n",(0,i.jsx)(r.li,{children:"Provides metrics including end-to-end replication latency across multiple data centers/clusters"}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.strong,{children:"Emits offsets required to migrate consumers between clusters."})}),"\n",(0,i.jsx)(r.li,{children:"Tooling for offset translation."}),"\n",(0,i.jsx)(r.li,{children:"No data or partition rebalancing, guarantees ordering within partition"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"mirrormaker-2-limitations",children:"MirrorMaker 2 Limitations"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"MirrorMaker 2 does not expose replication lag or throughput metrics"}),"\n",(0,i.jsx)(r.li,{children:"Automatically sync offset, but need to create a system for offset translation"}),"\n",(0,i.jsx)(r.li,{children:"Limited documentation for monitoring, tuning, and securing your MirrorMaker 2 Configuration"}),"\n",(0,i.jsx)(r.li,{children:"Failover logic is application-specific and can be time-consuming to set up and maintain"}),"\n",(0,i.jsx)(r.li,{children:"Changes to MirrorMaker 2 must be made on the properties file and requires the restart of the connect cluster"}),"\n",(0,i.jsxs)(r.li,{children:["Scaling requires significant overhead","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Requires 4 connectors and 3 internal topics"}),"\n",(0,i.jsx)(r.li,{children:"Each destination cluster needs a MirrorMaker 2 connector configured"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"offset-mapping",children:"Offset Mapping"}),"\n",(0,i.jsxs)(r.p,{children:["MM2 uses 2 internal topics to track the mapping of source and target offsets as well as the mapping between the source consumer_offsets to the target offset. The offset_sync topic at the target cluster maps the source topic, partition and offset with the corresponding offset at the target. MM2 gets the target offset from the RecordMetadata returned by ",(0,i.jsx)(r.code,{children:"producer.send()"}),"."]}),"\n",(0,i.jsxs)(r.p,{children:["For consumers relying on the ",(0,i.jsx)(r.code,{children:"__consumer_offsets"})," topic to track progress, MM2 maps the consumer offsets in a separate log compacted ",(0,i.jsx)(r.code,{children:"__checkpoint"})," topic per source cluster. MM2 periodically queries the source cluster for all committed offsets from all consumer groups, filters for those topics and consumer groups that need to be replicated and emits a message to the internal checkpoints topic at the target cluster. These checkpoint records are emitted at a configurable interval that can be dynamically controlled."]}),"\n",(0,i.jsx)(r.p,{children:"Using the checkpoint topic, a consumer, on failover, can directly determine (using the MM2 utilities) the target offset corresponding to the source committed offset that it needs to start consuming from."}),"\n",(0,i.jsx)(r.h4,{id:"offset-translation",children:"Offset Translation"}),"\n",(0,i.jsx)(r.p,{children:"The offset translation is great feature to serve the foundation of migrating or failing over downstream consumers (including Kafka stream applications) from the primary to the backup cluster, as the consumers will use the translated offsets to resume the consumption from where they left off at the primary cluster, without losing messages or consuming many duplicate messages. This expectation essentially contributes to a smooth and transparent one-time migration of consumers from one to another cluster, or the failover of consumers from primary to backup cluster."}),"\n",(0,i.jsxs)(r.p,{children:["To achieve the above transition, there are two important steps: (1) consumer offsets can be translated into the ones that make sense in another cluster, which is already done by the current MM 2.0. (2) periodically synchronize the translated offsets to the  ",(0,i.jsx)(r.code,{children:"___consumer_offsets_"})," topic, so that when the consumers switch over to the other cluster, they can start off from the last known and translated offsets."]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://cwiki.apache.org/confluence/display/KAFKA/KIP-545%3A+support+automated+consumer+offset+sync+across+clusters+in+MM+2.0",children:"KIP-545: support automated consumer offset sync across clusters in MM 2.0 - Apache Kafka - Apache Software Foundation"})}),"\n",(0,i.jsx)(r.h3,{id:"links",children:"Links"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://kafka.apache.org/documentation/#mirrormakerconfigs",children:"Apache Kafka Mirrormaker Configs Documentation"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://blog.cloudera.com/kafka-replication-the-case-for-mirrormaker-2-0/",children:"Kafka Replication: The case for MirrorMaker 2.0 - Cloudera Blog"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://blog.cloudera.com/a-look-inside-kafka-mirrormaker-2/",children:"A look inside Kafka Mirrormaker 2 - Cloudera Blog"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://engineering.sada.com/kafka-migration-from-on-prem-to-confluent-1bd03c3689f3",children:"Kafka migration from on-prem to Confluent | by SADA | The SADA Engineering Blog"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://docs.confluent.io/operator/current/co-configure-replicator.html",children:"Use Confluent for Kubernetes to configure Kafka Replicator | Confluent Documentation"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://docs.confluent.io/platform/current/multi-dc-deployments/replicator/index.html",children:"Replicator Overview | Confluent Documentation"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=epfif3Vnd0s",children:"MirrorMaker 2: Replicate Data Between Multicloud Kafka Clusters | Hybrid and Multicloud Architecture - YouTube"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://medium.com/@maxy_ermayank/migrating-kafka-with-mirror-maker-2-and-kafka-connect-a-step-by-step-guide-c43e1b91555a",children:"Migrating Kafka with Mirror Maker 2 and Kafka Connect: A Step-by-Step Guide | by Mayank Patel | Medium"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://cwiki.apache.org/confluence/display/KAFKA/KIP-545%3A+support+automated+consumer+offset+sync+across+clusters+in+MM+2.0",children:"KIP-545: support automated consumer offset sync across clusters in MM 2.0 - Apache Kafka - Apache Software Foundation"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.confluent.io/kafka-summit-lon19/disaster-recovery-with-mirrormaker-2-0/",children:"Disaster Recovery with MirrorMaker 2.0 - Confluent"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://medium.com/larus-team/how-to-setup-mirrormaker-2-0-on-apache-kafka-multi-cluster-environment-87712d7997a4",children:"How to setup MirrorMaker 2.0 on Apache Kafka multi-cluster environment | by Mauro Roiter | LARUS | Medium"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://platformatory.io/blog/How-to-migrate-kafka-clusters-without-downtime/",children:"How to migrate Kafka clusters without downtime | The Write Ahead Log"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.instaclustr.com/support/documentation/kafka/kafka-cluster-operations/setting-up-mirror-maker/",children:"Setting up Mirror Maker"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://developers.redhat.com/articles/2023/11/13/demystifying-kafka-mirrormaker-2-use-cases-and-architecture#",children:"Demystifying Kafka MirrorMaker 2: Use cases and architecture | Red Hat Developer"})}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"confluent-replicator-vs-mirrormaker-20",children:"Confluent Replicator vs MirrorMaker 2.0"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://stackoverflow.com/questions/60211903/mirrormaker2-0-vs-confluent-replicator",children:"apache kafka - Mirrormaker2.0 vs confluent replicator - Stack Overflow"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://docs.confluent.io/platform/current/multi-dc-deployments/replicator/migrate-replicator.html",children:"Migrate from Apache Kafka MirrorMaker to Confluent Replicator | Confluent Documentation"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.linkedin.com/pulse/confluent-replicator-vs-mirrormaker20-open-source-center-ishan-gandhi/",children:"Confluent Replicator vs MirrorMaker2.0 (open source) for multi-data center data Replication"})}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"migration",children:"Migration"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"https://medium.com/miq-tech-and-analytics/how-to-migrate-kafka-cluster-with-zero-downtime-38653dfe9a76",children:"How to Migrate Kafka Cluster with Zero Downtime | by Dheeraj Kulakarni | MiQ Tech and Analytics | Medium"})})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://blogit.michelin.io/migrate-your-applications-from-kafka-onprem-to-a-manage-service/",children:"Migrate Applications from Kafka On-Premise to Confluent Cloud"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://towardsdatascience.com/migration-tool-and-tips-of-kafka-cross-cluster-replication-mirrormaker-7e0157eecf19",children:"Migration Tool and Tips of Kafka cross-cluster replication: MirrorMaker | by Ning.Zhang | Towards Data Science"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=oqRiagSnYfQ",children:"Migrate Your Kafka Cluster with Minimal Downtime - YouTube"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=epfif3Vnd0s&ab_channel=Confluent",children:"MirrorMaker 2: Replicate Data Between Multicloud Kafka Clusters | Hybrid and Multicloud Architecture - YouTube"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=cZatGgveaLg&ab_channel=Confluent",children:"Replicate Data Between Multicloud Kafka Clusters with Confluent | Hybrid and Multicloud Architecture - YouTube"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=Q0eH9xhZUjg&ab_channel=DataCouncil",children:"Apache Kafka Migration: How to Migrate to Apache Kafka by Rafe Colburn (Etsy) - YouTube"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsxs)(r.a,{href:"https://www.youtube.com/watch?v=CmcJb9Ge3jI&ab_channel=AWSEvents",children:["AWS re",":Invent"," 2020: Guide to Apache Kafka replication and migration with Amazon MSK - YouTube"]})}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"cluster-linking",children:"Cluster Linking"}),"\n",(0,i.jsx)(r.p,{children:"Cluster Linking allows you to directly connect clusters and perfectly mirror topics, consumer offsets, and ACLs from one cluster to another."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://www.youtube.com/watch?v=D8VeBdDg7xI&ab_channel=Confluent",children:"Learn about Confluent Cluster Linking | Hybrid and Multicloud Architecture - YouTube"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://developer.confluent.io/courses/hybrid-cloud/intro/",children:"Hands-on Course - Introduction to Hybrid and Multicloud Architecture"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://docs.confluent.io/platform/current/multi-dc-deployments/cluster-linking/index.html",children:"Overview of Cluster Linking Confluent Platform | Confluent Documentation"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://docs.confluent.io/cloud/current/multi-cloud/cluster-linking/index.html",children:"Cluster Linking on Confluent Cloud for data sharing across multi-region clusters | Confluent Documentation"})}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"scaling",children:"Scaling"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.a,{href:"https://github.com/orgs/strimzi/discussions/6635",children:"Is there anyway to activate auto scaling or some form of auto scaling with Strimzi? \xb7 strimzi \xb7 Discussion #6635 \xb7 GitHub"})}),"\n",(0,i.jsx)(r.p,{children:"Auto-scaling Kafka is complicated. It usually cannot be done just based on some CPU utilization etc."}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["If you want to scale consumers, you need to understand their consumer group membership and which topics are they consuming. Because the maximum number of replicas is for example limited with number of partitions from which they are consuming. You need to use tools such as for example ",(0,i.jsx)(r.a,{href:"https://keda.sh/",children:"KEDA"})," to autoscale them which have some additional logic to take these things into account."]}),"\n",(0,i.jsxs)(r.li,{children:["If you want to auto-scale components such as Connect, Connectors, Bridge etc., Strimzi gives you the ",(0,i.jsx)(r.code,{children:"scale"})," subresources to plug it into Kubernetes HPA and tools like KEDA. These are basically consumers and producers in a special packaging. So the same rules as described above apply for them."]}),"\n",(0,i.jsx)(r.li,{children:"For Kafka brokers, auto-scaling is complicated because of their architecture. Adding or removing brokers is simple. But directing some load to them is complicated because they are in a way form of data storage. And moving the whole partitions between brokers is expensive. The partitions often contain huge amounts of data which need to be shifted from one broker to another - that will take time, it will have a performance penalty on the other traffic and possibly cost even real money for the data transfers. Plus it still might not work because if your bottleneck is for example a topic with 5 partitions, it might not matter whether you have 5 or 10 brokers. So from my experience, only rarely autoscaling of Kafka brokers makes sense."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"others",children:"Others"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://docs.lenses.io/latest/k2k/install",children:"Install | Lenses Docs"})}),"\n"]})]})}function d(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>s});var n=t(296540);const i={},o=n.createContext(i);function a(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);