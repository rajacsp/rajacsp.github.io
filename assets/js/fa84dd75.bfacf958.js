"use strict";(self.webpackChunkdeep_notes=self.webpackChunkdeep_notes||[]).push([[7260],{802039:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"ai/move-37/open-ai-gym","title":"Open AI Gym","description":"FronzenLake-v0","source":"@site/docs/ai/move-37/open-ai-gym.md","sourceDirName":"ai/move-37","slug":"/ai/move-37/open-ai-gym","permalink":"/ai/move-37/open-ai-gym","draft":false,"unlisted":false,"editUrl":"https://github.com/rajacsp/rajacsp.github.io/tree/master/docs/ai/move-37/open-ai-gym.md","tags":[],"version":"current","lastUpdatedBy":"Deepak","lastUpdatedAt":1701793554000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Algorithms","permalink":"/ai/move-37/algorithms"},"next":{"title":"Others","permalink":"/ai/move-37/others"}}');var o=t(474848),r=t(28453);const i={},s="Open AI Gym",l={},c=[{value:"FronzenLake-v0",id:"fronzenlake-v0",level:2},{value:"BipedalWalker-v2",id:"bipedalwalker-v2",level:2},{value:"References",id:"references",level:2}];function d(e){const n={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"open-ai-gym",children:"Open AI Gym"})}),"\n",(0,o.jsx)(n.h2,{id:"fronzenlake-v0",children:"FronzenLake-v0"}),"\n",(0,o.jsx)(n.p,{children:"The agent controls the movement of a character in a grid world. Some tiles of the grid are walkable, and others lead to the agent falling into the water. Additionally, the movement direction of the agent is uncertain and only partially depends on the chosen direction. The agent is rewarded for finding a walkable path to a goal tile."}),"\n",(0,o.jsx)(n.h2,{id:"bipedalwalker-v2",children:"BipedalWalker-v2"}),"\n",(0,o.jsx)(n.p,{children:"Reward is given for moving forward, total 300+ points up to the far end. If the robot falls, it gets -100. Applying motor torque costs a small amount of points, more optimal agent will get better score. State consists of hull angle speed, angular velocity, horizontal speed, vertical speed, position of joints and joints angular speed, legs contact with ground, and 10 lidar rangefinder measurements. There's no coordinates in the state vector."}),"\n",(0,o.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"http://kvfrans.com/simple-algoritms-for-solving-cartpole",children:"http://kvfrans.com/simple-algoritms-for-solving-cartpole"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://github.com/kvfrans/openai-cartpole",children:"https://github.com/kvfrans/openai-cartpole"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://gym.openai.com/envs/FrozenLake-v0",children:"https://gym.openai.com/envs/FrozenLake-v0"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://gym.openai.com/envs/BipedalWalker-v2",children:"https://gym.openai.com/envs/BipedalWalker-v2"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var a=t(296540);const o={},r=a.createContext(o);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);